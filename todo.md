
1. Токены никак не проверяются: в src/auth/index.ts генерируются случайные строки, не подписываются, не хранятся, срок жизни access-токена нигде не проверяется, а маршруты (src/routes/users/users.route.ts, src/routes/registration/registration.route.ts и др.) не защищены вообще.
2. Refresh‑токены складируются, но не используются: нет эндпоинта для обновления, нет проверки expiresAt/revoked, нет отзыва на logout, нет чистки просроченных; токены лежат в БД в открытом виде (src/db/index.ts, src/db/schema.ts).
3. Нет носителя для токена: токены отдаются только в JSON, не кладутся в httpOnly cookie, не задаются атрибуты secure/sameSite для защиты в браузере.
4. Валидации тела запросов нет: /api/auth и /api/registration принимают произвольный input без схемы; нет обработки уникальности email (придёт 500 от БД).
5. Конфиг невалидируемый и рассинхронизирован: REFRESH_TOKEN_TTL_DAYS, ACCESS_TOKEN_TTL_MINUTES, JWT_SECRET есть в .env.example, но не задекларированы в envSchema и не проходят через app.config; берутся напрямую из process.env, что ломает типизацию и тестируемость.
6. Нет механизма авторизации для последующих запросов: отсутствует preHandler/плагин (JWT/сессии) и привязка пользователя к request (и, соответственно, аудита и ограничения по userId).
7. Мелочи: refresh token TTL/rotation не реализованы; нет rate limiting/brute-force защиты для /api/auth; типы UserDTO/dbTypes расходятся по id (string vs number).
Куда двигаться дальше:
___
1. Определиться со стратегией токенов (JWT или opaque + серверная сессия), добавить валидацию/хранение/проверку срока и middleware на защищённые маршруты.
2. Реализовать refresh/logout/rotation и хранить refresh токены захэшированными.
3. Подключить схему валидации (zod/typebox) на входах и нормальную работу с конфигом через fastify-env.
4. Решить, где хранить токены в браузере (httpOnly cookie) и включить базовую защиту (rate limit, error messages 4.без утечек).